# Веб-ларёк

Интернет-магазин с товарами для веб-разработчиков: каталог, просмотр товара, корзина и двухшаговое оформление заказа.

## Стек

* **TypeScript**
* **Webpack 5** (dev-server, сборка)
* **SCSS** (БЭМ)
* **ESLint + Prettier**
* **Babel** (`preset-env`)
* **dotenv** (переменные окружения)
* Инфраструктура: `Api` (HTTP-клиент), `EventEmitter` (событийная шина)

## Быстрый старт

**1) Установить зависимости**

```bash
npm i
```

**2) Создать `.env` в корне**

```dotenv
API_ORIGIN=https://larek-api.nomoreparties.co
```

> Важно: без завершающего слэша.

**3) Запуск в dev-режиме**

```bash
npm run start
```

**4) Сборка и разработка**

```bash
npm run build        # production
npm run build:dev    # development
npm run watch        # наблюдение
```

**5) Линтинг/форматирование**

```bash
npm run lint
npm run lint:fix
npm run format
```

## Структура проекта (основное)

```
src/
  index.ts             # точка входа (презентер-сценарий)
  types/
    index.ts           # интерфейсы/типы данных (товары, корзина, заказ, события и т.п.)
  components/
    base/
      api.ts           # базовый API-клиент
      events.ts        # брокер событий (EventEmitter)
  common.blocks/       # БЭМ-блоки и стили
  scss/                # общие стили
  images/, vendor/     # ассеты и шрифты
```

## Парадигма и слои (MVP + событийная шина)

Применяется **MVP**:

* **Model** — слой, который **работает только с данными** (хранение, простая трансформация, валидация). **Сетью не занимается.**
* **View** — слой, который **только отображает данные** и генерирует UI-события. **Не знает о сети и моделях.**
* **Presenter** — связующее звено (в нашем случае — код в `src/index.ts`). Получает данные с сервера, передаёт их в модели, подписывает обработчики событий и инициирует обновление представлений.

> Получение данных с сервера (HTTP-запросы) выполняется **в презентере** и только в нём. Модель получает уже готовые данные на вход и сохраняет их.

## События (ключевые)

* `items:change` — каталог обновлён в модели (массив атрибутов товаров).
* `product:select` — пользователь кликнул карточку в галерее.
* `basket:add` / `basket:remove` / `basket:updated` / `basket:open` — операции с корзиной.
* `order:fill-step1` / `order:fill-step2` / `order:submit` / `order:success` / `order:error` — оформление заказа.
* `modal:open` / `modal:close` — управление модальным контейнером.
* `form:errors` / `form:valid` — результаты валидации полей.

## Классы (описание, без кода)

### Слой Model

**CatalogModel**
**Назначение:** хранит массив атрибутов товаров, подготовленных к показу.
**Конструктор:** `(events)`
**Поля:**

* `items: IProductApi[]` — актуальный список атрибутов товаров.
  **Методы:**
* `setItems(items: IProductApi[])` — сохраняет список и эмитит `items:change` с `items`.
* `getById(id: ID)` — возвращает объект из `items` или `undefined`.

**BasketModel**
**Назначение:** хранит состояние корзины.
**Конструктор:** `(events)`
**Поля:**

* `items: BasketItem[]` — позиции в корзине (минимально необходимый набор атрибутов).
  **Методы:**
* `add(item: BasketItem)` / `remove(id: ID)` / `clear()` — меняют состав и эмитят `basket:updated`.
* `total()` — вычисляет сумму (цены `null` не учитываются).
* `has(id: ID)` — проверяет наличие позиции.

**OrderModel**
**Назначение:** хранит состояние двух форм, валидирует и готовит запрос заказа.
**Конструктор:** `(events)`
**Поля:**

* `step1: { payment, address }`
* `step2: { email, phone }`
  **Методы:**
* `setStep1(part)` — обновляет + валидирует; эмитит `form:errors`/`form:valid`.
* `setStep2(part)` — обновляет + валидирует; эмитит `form:errors`/`form:valid`.
* `toRequest(items: ID[], total: number)` — собирает `IOrderRequest`.
* `reset()` — сбрасывает оба шага.

### Слой View

**MainPageView** (ГЛАВНАЯ СТРАНИЦА)  
**Назначение:** показывает галерею товаров и элементы шапки.  
**Конструктор:** `(root, events)`

**Поля:**
- Корневой контейнер галереи.
- Кнопка с иконкой корзины — `.header__basket`.
- Счётчик товаров — `.header__basket-counter`.

**Методы:**
- `renderList(nodes: HTMLElement[])` — принимает **готовый массив** DOM-узлов карточек и вставляет через `replaceChildren(...)`. **Событий не генерирует.**
- `setCounter(count: number)` — обновляет значение `.header__basket-counter`. Вызывается презентером на событие `basket:updated` (например, `setCounter(state.items.length)`).
- При клике на иконку корзины — эмитит `basket:open`.

**CardView** (ЕДИНЫЙ класс карточки)
**Назначение:** создаёт один DOM-узел карточки по переданному шаблону.
**Конструктор:** `(template: HTMLTemplateElement, events)`
**Методы:**

* `render(attrs: IProductApi): HTMLElement` — возвращает готовую карточку.
* В режиме галереи вешает обработчик клика и эмитит `product:select` с `{ id }`.

> В проекте 3 шаблона карточки в `index.html`: для галереи, для превью (модалка товара) и для корзины. Один класс `CardView`, разные шаблоны.

**ModalView** (ОДИН универсальный контейнер)
**Назначение:** показывает **любой** переданный контент.
**Конструктор:** `(container, events)` для `#modal-container`.
**Методы:**

* `render(content: HTMLElement)` — монтирует контент в контейнер.
* `open()` / `close()` — управляет видимостью; закрытие по крестику и клику по оверлею.

**PreviewView** (контент модалки товара)
**Назначение:** выводит детали товара; кнопки «Купить/Убрать».
**Методы:**

* `render(attrs: IProductApi, inBasket: boolean): HTMLElement` — возвращает контент для `ModalView.render(...)`.
* Эмитит `basket:add`/`basket:remove`.

**BasketView** (контент модалки корзины)
**Назначение:** показывает список карточек корзины и сумму.
**Методы:**

* `renderList(nodes: HTMLElement[], total: number): HTMLElement` — возвращает контент для модалки; `nodes` — **готовые** DOM-узлы карточек корзины.
* Кнопки: «Оформить» → `order:fill-step1`.

**OrderStep1View / OrderStep2View** (контент модалки оформления)
**Назначение:** формы «оплата+адрес» и «контакты».
**Методы:**

* `render(data)` — возвращает контент для модалки; эмитят `order:fill-step1` / `order:fill-step2` и `order:submit`.

**OrderSuccessView** (контент финального сообщения)  
**Назначение:** отрисовать содержимое модального окна после успешного оформления заказа.

**Конструктор:** `(template: HTMLTemplateElement, onClose: () => void)`  
Получает ссылку на шаблон из `index.html` и колбэк закрытия модального окна. В конструкторе создаётся клон шаблона, кэшируются нужные узлы и навешивается обработчик клика на кнопку закрытия, который вызывает переданный `onClose` (обычно `() => modal.close()`).

**Поля (кэш DOM):**
- `template: HTMLTemplateElement` — исходный шаблон из `index.html`.
- `root: HTMLElement` — корень сгенерированного контента (клон шаблона).
- `totalEl: HTMLElement` — узел для вывода суммы списания.
- `messageEl?: HTMLElement` — узел для доп. текста.
- `closeBtn?: HTMLButtonElement` — кнопка закрытия/подтверждения.
- `onClose: () => void` — колбэк закрытия модалки, переданный извне (из `index.ts`).

**Методы:**
- `render(total: number, orderId?: ID): HTMLElement` — подставляет значения (`total`, `orderId`) в уже сконструированный DOM и **возвращает `HTMLElement`**.  
  Пример использования: `modal.render(successView.render(total, orderId)); modal.open();`

> Обработчики навешиваются **в конструкторе**, благодаря чему класс создаёт обработку один раз и остаётся «тонким» при повторных рендерах.

### Презентер (index.ts)

* Вызывает API для получения каталога.
* Передаёт массив атрибутов в `CatalogModel.setItems(items)`; модель сохраняет и эмитит `items:change`.
* На `items:change` строит массив DOM-узлов карточек (`CardView` + шаблон галереи) и передаёт в `MainPageView.renderList(nodes)`.
* На `product:select` открывает модалку превью (`PreviewView` → `ModalView.render(...)` + `open()`).
* Операции с корзиной → обновление `BasketModel` → `basket:updated` → `BasketView.renderList(...)` → `ModalView.render(...)`.
* Формы заказа — по аналогичной схеме событий.

## Сценарий взаимодействия (V → P → M → P → V)

**Кейс:** клик по карточке в галерее → превью товара в модалке.

1. **V:** экземпляр `CardView` в галерее ловит клик и эмитит **`product:select`** с `{ id }`.
2. **P:** презентер (в `src/index.ts`) обрабатывает `product:select`, берёт товар из `CatalogModel.getById(id)` и собирает контент превью через `PreviewView.render(attrs, inBasket)`.
3. **P → V:** презентер передаёт контент в `ModalView.render(content)` и вызывает `ModalView.open()`.
4. **V → P:** в превью пользователь жмёт «Купить» → `PreviewView` эмитит **`basket:add`** с `{ id, title, price }`.
5. **P → M:** презентер вызывает `BasketModel.add(item)`.
6. **M:** `BasketModel` обновляет `items/total` и эмитит **`basket:updated`** с `{ state }`.
7. **P → V:** презентер обновляет счётчик на главной (`MainPageView`) и, если открыта корзина, пересобирает её контент: `BasketView.renderList(nodes, state.total)` → `ModalView.render(content)`.

> `MainPageView.renderList(nodes: HTMLElement[])` и `BasketView.renderList(nodes: HTMLElement[], total: number)` получают **готовые DOM-узлы** карточек и не зависят от шаблонов карточки.

## Данные и типы

* **Дублирования нет.** Базовая сущность товара — `IProductApi`.
* Если нужен вариант с необязательными полями — используем `Partial<IProductApi>` в коде, а не отдельный интерфейс.
* Позиция корзины не дублирует товар, а выводится из него: `type BasketItem = Pick<IProductApi, 'id' | 'title' | 'price'>`.
* Преобразование цены в строку выполняется функцией-утилитой (например, `(price) => string`); отдельное поле `priceLabel` в типы не добавляется.

Полный список типов — в `src/types/index.ts`.

## Функциональные требования

* **Главная:** галерея товаров; клик по карточке — модалка с деталями; клик по иконке корзины — модалка корзины.
* **Просмотр товара:** «Купить» — добавить (если не в корзине); «Убрать» — удалить.
* **Оформление заказа:**

  * Шаг 1 — способ оплаты (`card`/`cash`), адрес (обязателен).
  * Шаг 2 — email и телефон (обязательны).
  * Оплата → сообщение об успехе и очистка корзины.
* **Модалки** закрываются по клику вне и по крестику.
* Кнопки «Далее/Оплатить» доступны только при валидных данных текущего шага.